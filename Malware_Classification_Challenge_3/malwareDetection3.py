##Classify malware into one of 10 classes it can belong to, each malware is recognized by its md5 signature,Single signature is present
# per Anti Virus per sample. However, each sample may vary in
#the presence of an Anti Virus and its signature.
##info per signature is given, not particular to any tarining or test data.
#train data- sinature plus label, test data- signature
#  each signature -  develop corresponding features.
# use signature in training with developed features and labels tarining data
# use signature in testin with developed features for test data.

#  We analyzed the variance of dierent anti
#viruses and their corresponding range of signatures.for eah mall
##ware static info that is anitvirus with corresponding signature ran against it was given, (we can compute most frquently used
# antivirus , and no of signatures of taht virus exist, no of malwares taht antivirus is used, we can get top most used antivirus, wi
# th thier top 10 signatures they are used with, SEcondly for each sample(malware) we have static data(for each training sampel we
# have list of md5 signatures (malware signature)), used that as well, we can use this info1. to study contribution of Ã©ach
# antivirus signature for classification label, contribution of static info :for each  md5 signature(malware) we have static info and
# classification label it belongs to , a signature- info- label, for same a - another info- another label, max label for that)

import numpy as np
import pandas as pd
import os

os.chdir('C:\\Users\\priyagoe\\Downloads\\Anomaly-Detection-practical-master\\Anomaly-Detection-practical-master\\Challenges\\Malware_Classification_Challenge_3\\')

##Reading Data

XTraindf = pd.read_csv('training_data.csv')
# print XTrain[0]
XTestdf = pd.read_csv('test_data_public_new.csv')
# print XTest[0]

XTrain =XTraindf.as_matrix()
XTest = XTestdf.as_matrix()
YTrain = XTrain[:,-1]
XTrain = XTrain[:,1]
print (XTrain.shape)
YTrain = YTrain.astype(np.int)
print(type(YTrain[0]),YTrain[0],YTrain.shape)
print (XTest.shape)
XTest = XTest[:,1]

import pickle,os,json
def readFile(fileName):
    return pickle.load( open( fileName, "rb" ) )


##Data cleaning, remove missing data , as we have enough data for training
def missingTestCases(X,folder):
    missingIndices = []
    for i in range(X.shape[0]):
        try:
            readFile(os.getcwd()+os.sep+folder+os.sep+X[i]+'.bin')
        except IOError:
            missingIndices.append(i)
    return missingIndices

missingIndicesPEXTrain = missingTestCases(XTrain,'peinfo')
missingIndicesVTXTrain = missingTestCases(XTrain,'vt')
missingIndicesPEXTest = missingTestCases(XTest,'peinfo')
missingIndicesVTXTest = missingTestCases(XTest,'vt')
assert(np.array_equal(missingIndicesPEXTrain,missingIndicesVTXTrain))
assert(np.array_equal(missingIndicesPEXTest,missingIndicesVTXTest))
print (len(missingIndicesVTXTest),len(missingIndicesPEXTrain))
newXTrain = np.delete(XTrain,missingIndicesPEXTrain)
newYTrain = np.delete(YTrain,missingIndicesPEXTrain)
print (newXTrain.shape)
print (newYTrain.shape)
newYTrain.astype(np.int)


##Feature Engineering

##analysis of vtInfo

from tabulate import tabulate
from operator import itemgetter, attrgetter

VTRange = {}
folder = 'vt'
for i in range(newXTrain.shape[0]):
    VTInfo = readFile(os.getcwd() + os.path.sep + folder + os.path.sep + newXTrain[i] + '.bin')
    for key in VTInfo.keys():
        if key not in VTRange.keys():
            VTRange[key] = []
        VTRange[key].append(VTInfo[key])

freqAV = []
head = ['Anti Viruse Name', 'No. of Labels', 'No. Of Samples', 'Ratio of Samples/Labels']

for k in VTRange.keys():
    #     print k, len(list(set(VTRange[k]))),len(VTRange[k]), len(VTRange[k])/float(len(list(set(VTRange[k]))))
    freqAV.append([k, len(list(set(VTRange[k]))), len(VTRange[k]), len(VTRange[k]) / float(len(list(set(VTRange[k]))))])

descSortedfreqAV = sorted(freqAV, key=itemgetter(3), reverse=True)
print (tabulate(descSortedfreqAV, headers=head))

with open('result.json', 'w') as fp:
    json.dump(VTRange, fp, sort_keys=True, indent=4, separators=(',', ': '))

'''Explanation of relevant result subtypes:
pe_section - data about different sections of the PE file
pe_resources - data about resources included in the PE file (images, icons, menus...)
pe_import - data about imported functions from DLLs
pe_timestamp - timestamp from compilation time
rich_header - part of the PE header, contains some custom data about the PE file'''

PERange = {}
PERange['pe_section'] = {}
PERange['pe_resource'] = {}
PERange['pe_import'] = {}
PERange['pe_timestamp'] = {}
PERange['rich_header'] = {}
relevantSubTypes = ['pe_section', 'pe_resource', 'pe_import', 'pe_timestamp', 'rich_header']

folder = 'peinfo'
for i in range(newXTrain.shape[0]):
    PEInfo = readFile(os.getcwd() + os.path.sep + folder + os.path.sep + newXTrain[i] + '.bin')
    for PEItem in PEInfo:
        subType = PEItem['subtype']
        if subType not in relevantSubTypes:
            continue
        for key in PEItem.keys():
            if key == 'subtype':
                continue
            elif key not in PERange[subType].keys():
                PERange[subType][key] = []
            PERange[subType][key].append(PEItem[key])

with open('PEInfo_Analysis.json', 'w') as fp:
    json.dump(PERange, fp, sort_keys=True, indent=4, separators=(',', ': '))
# print json.dumps(PERange, sort_keys=True,indent=4, separators=(',', ': '))


# print json.dumps(PERange['pe_section'], sort_keys=True,indent=4, separators=(',', ': '))
sections = ['pe_section','pe_resource','pe_import','pe_timestamp','rich_header']
def printSectionReport(PERange, section):
    print ('\n'+section)
    print ('_'*len(section))
    for k in PERange[section].keys():
        print (k, len(list(set(PERange[section][k]))),len(PERange[section][k]), len(PERange[section][k])/float(len(list(set(PERange[section][k])))))
for section in sections:
    printSectionReport(PERange,section)

with open('PEInfo_Analysis_pe_resource.json', 'w') as fp:
    json.dump(PERange['pe_resource'], fp, sort_keys=True,indent=4, separators=(',', ': '))

with open('PEInfo_Analysis_pe_import.json', 'w') as fp:
    json.dump(PERange['pe_import'], fp, sort_keys=True,indent=4, separators=(',', ': '))

with open('PEInfo_Analysis_pe_timestamp.json', 'w') as fp:
    json.dump(PERange['pe_timestamp'], fp, sort_keys=True,indent=4, separators=(',', ': '))

with open('PEInfo_Analysis_rich_header.json', 'w') as fp:
    json.dump(PERange['rich_header'], fp, sort_keys=True,indent=4, separators=(',', ': '))

##craete feature vector with vtinfo
def CreateFeatureVec(X,folder,VTInfoTaken):
    XFeatures = []
    for i in range(X.shape[0]):
        XFeatures.append([])
        VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
        for key in VTInfoTaken:#VTInfo.keys():
            if key in VTInfo.keys():#VTInfoTaken:
    #             XTrainFeatures[i].append(VTInfo[key])
                XFeatures[i].append(1)
            else:
                XFeatures[i].append(0)
    return np.asarray(XFeatures)

##frequency encoding feature vectors
def CreateFeatureVecFreq(X,folder,VTInfoTaken):
    XFeatures = []
    for i in range(X.shape[0]):
        XFeatures.append([])
        VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
        for key in VTInfoTaken:#VTInfo.keys():
            if key in VTInfo.keys():#VTInfoTaken:
    #             XTrainFeatures[i].append(VTInfo[key])
#                 mean = 2.6366914849*75
                total = float(len(VTRange[key]))/len(list(set(VTRange[key])))
#                 total = len(list(set(VTRange[key])))/float(len(VTRange[key]))
                occurences = VTRange[key].count(VTInfo[key])
                if occurences == 0:
#                     print key, VTInfo[key], VTRange[key]
                    XFeatures[i].append(total)
                else:
#                 occurences = 1
                    XFeatures[i].append(total/occurences)
            else:
                XFeatures[i].append(0)
    return np.asarray(XFeatures)


def countNullVectors(vector, length):
    countNulls = 0
    for i in range(vector.shape[0]):
#         print type(vector[i,:])
        if np.count_nonzero(vector[i]) == 0:
#             print vector[i]
            countNulls +=1
    return countNulls


def median(lst):
    lst = sorted(lst)
    if len(lst) < 1:
        return None
    if len(lst) % 2 == 1:
        return lst[((len(lst) + 1) / 2) - 1]
    else:
        return float(sum(lst[(len(lst) / 2) - 1:(len(lst) / 2) + 1])) / 2.0

##Create feature vectors with peinfo
def CreateFeatureVecPEI(X, folder, PEInfoTaken, relevantSubTypes):
    XFeatures = []
    XFeaturesNorm = []
    for i in range(X.shape[0]):
        XFeatures.append({})
        XFeaturesNorm.append({})
        XFeaturesNorm2 = []
        PEInfo = readFile(os.getcwd() + os.path.sep + folder + os.path.sep + X[i] + '.bin')
        for PEItem in PEInfo:
            subType = PEItem['subtype']
            if subType not in relevantSubTypes:
                continue
            for key in PEInfoTaken:
                print(key)
                try:
                    XFeatures[i][key]
                except KeyError:
                    XFeatures[i][key] = []
                if key in PEItem.keys():
                    print(i)
                    XFeatures[i][key].append(PEItem[key])
                else:
                    XFeatures[i][key].append(0)
        print(XFeatures, len(XFeatures))
        # Mean
    for key in PEInfoTaken:
        print(XFeatures[i][key])
        print(len(XFeatures[i][key]))
        for n in XFeatures[i][key]:
            print(type(n))
        print(sum(float(x) for x in XFeatures[i][key]))
        XFeaturesNorm[i][key] = []
        XFeaturesNorm[i][key].append(sum(float(x) for x in XFeatures[i][key]) / len(XFeatures[i][key]))
        print(XFeaturesNorm[i][key])
        XFeaturesNorm2[i].append(XFeaturesNorm[i][key])
        # Mode
    #         XFeaturesNorm[i] = max(set(XFeatures[i].values()[0]), key=XFeatures[i].values()[0].count)
    # Median
    #         XFeaturesNorm[i] = median(XFeatures[i].values()[0])

    newFeatures = np.asarray(XFeaturesNorm2)
    #     print newFeatures.shape
    return np.reshape(newFeatures, (newFeatures.shape[0], len(PEInfoTaken)))




    # relevantSubTypes = ['pe_section']#,'pe_resource']
    # folder = 'peinfo'
    # PEInfoTaken = ['entropy']#, 'language','resource_id']
    # XTrainFeatures = CreateFeatureVecPEI(newXTrain[0:3],folder,PEInfoTaken,relevantSubTypes)
    # print XTrainFeatures
    # print XTrainFeatures.shape
    # relevantSubTypes = ['pe_resource']
    # PEInfoTaken = ['language']#, 'resource_id']

    # # XTrainFeaturesPE1 = CreateFeatureVecPEI(newXTrain[0:8],folder,PEInfoTaken,relevantSubTypes)
    # print XTrainFeaturesPE1
    # print XTrainFeaturesPE1.shape
    # print newXTrain[7]
    # a = readFile(os.getcwd()+'/peinfo/'+newXTrain[7]+'.bin')#[0]
    # print json.dumps(a, sort_keys=True,indent=4, separators=(',', ': '))

#Analyse signature of ech antivirus against classification label.
def AnalyseAntiVirusLabelContribution(X,folder,VTInfoTaken):
    from collections import Counter
    XFeatures = []
    for i in range(X.shape[0]):
        VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
        for key in VTInfoTaken:
            if key in VTInfo.keys():
                XFeatures.append((VTInfo[key], newYTrain[i]))
            else:
                pass
    return Counter(XFeatures)

folder = 'vt'
VTInfoTaken = [u'Symantec'] # ['Panda', 'AVware', 'VIPRE', 'Symantec']
XTrainFeatures = AnalyseAntiVirusLabelContribution(newXTrain,folder,VTInfoTaken)
print (XTrainFeatures)

##analyse signature of each antivirus
def AnalyseAntiVirusContribution(X,folder,VTInfoTaken):
    from collections import Counter
    XFeatures = []
    for i in range(X.shape[0]):
        VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
        for key in VTInfoTaken:
            if key in VTInfo.keys():
                XFeatures.append((VTInfo[key]))
            else:
                pass
    return Counter(XFeatures)

folder = 'vt'
VTInfoTaken = [u'Symantec'] # ['Panda', 'AVware', 'VIPRE', 'Symantec']
XTrainFeatures = AnalyseAntiVirusContribution(newXTrain,folder,VTInfoTaken)
print (XTrainFeatures)



# Limited One Hot Encoding of Features of each Anti Virus - Classification purely on VT Info
folder = 'vt'


def createLtdOHEonAVFeaturesVec(X,folder,VTInfoTaken, VTInfoTakenValues, topNFreqFeatures):
    XFeatures = []
    for i in range(X.shape[0]):
        XFeatures.append([])
        VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
        for key in VTInfoTaken:
            if key in VTInfo.keys():
                if key in VTInfoTaken:
                    if VTInfo[key] in VTInfoTakenValues:
                        XFeatures[i].append(VTInfoTakenValues.index(VTInfo[key]) + 1)
                    else:
                        XFeatures[i].append(topNFreqFeatures + 1)
            else:
                XFeatures[i].append(0)
    return np.asarray(XFeatures)

#Get the important features based on the frequency of occurence across different Anti-Virus(you can understand everything with this function)
def getFeatureFeqAV(X, folder, noOfAntiVirus, topNFreqFeatures):
    VTInfoTakenValues = []
    XFeatures = []

    # Get the top most frequent Anti Viruses based on the input parameter noOfAntiVirus
    for i in range(newXTrain.shape[0]):
        VTInfo = readFile(os.getcwd() + os.path.sep + folder + os.path.sep + newXTrain[i] + '.bin')
        for key in VTInfo.keys():
            if key not in VTRange.keys():
                VTRange[key] = []
            VTRange[key].append(VTInfo[key])

    freqAntiVirus = []
    for k in VTRange.keys():
        freqAntiVirus += [(k, len(list(set(VTRange[k]))), len(VTRange[k]), len(VTRange[k]) / float(len(list(set(VTRange[k])))))]

    from operator import itemgetter, attrgetter
    descSortedFreqAntiVirus = sorted(freqAntiVirus, key=itemgetter(3), reverse=True)

    # Select the top most frequent Anti Viruses
    VTInfoTaken = [x[0] for x in descSortedFreqAntiVirus[0:noOfAntiVirus]]
    # print VTInfoTaken

    VTInfoTakenValues = []
    for i in range(noOfAntiVirus):
        countXTrainFeatures = AnalyseAntiVirusContribution(X, folder, [VTInfoTaken[i]])
        descSortedXTrainFeatures = sorted(countXTrainFeatures, key=itemgetter(1), reverse=True)
        topNFreqXTrainFeatures = [x[0] for x in descSortedXTrainFeatures[0:topNFreqFeatures]]
        VTInfoTakenValues.append(topNFreqXTrainFeatures)

    XFeatures = createLtdOHEonAVFeaturesVec(X, folder, VTInfoTaken, VTInfoTakenValues, topNFreqFeatures)
    return XFeatures

XFeatures = getFeatureFeqAV(newXTrain, 'vt', 10, 10)
print (XFeatures)

##model definition

#different classifier to train the model.
# Random Forest Classifier
from sklearn.ensemble import RandomForestClassifier
# def classifyRandomForestClassifier(XTrain, XTest, YTrain, YTest,trees=100,crit='gini'):
def classifyRandomForestClassifier(XTrain, XTest, YTrain, YTest, params):
    trees = params['trees']
    crit = params['criterion']
    clf = RandomForestClassifier(n_estimators=trees,criterion=crit)
    clf.fit(XTrain, YTrain)
    YPred = clf.predict(XTest)
    diff = YPred - YTest
    score = diff[diff == 0].size
    return (100.0 * score)/(YPred.size)

#Multi Class SVM
from sklearn import svm
def classifyMultiClassSVMClassifier(XTrain, XTest, YTrain, YTest, params):
    ker = params['kernel']
    YPred = svm.SVC(kernel=ker).fit(XTrain, YTrain).predict(XTest)
    diff = YPred - YTest
    score = diff[diff == 0].size
    return (100.0 * score)/(YPred.size)

#K Nearest Neighbours Classifier
from sklearn.neighbors import KNeighborsClassifier
def classifyKNNClassifier(XTrain, XTest, YTrain, YTest, params):
    neighbours = params['neighbours']
    neigh = KNeighborsClassifier(n_neighbors=neighbours)
    YPred = neigh.fit(XTrain, YTrain).predict(XTest)
    diff = YPred - YTest
    score = diff[diff == 0].size
    return (100.0 * score)/(YPred.size)


##startified k fold cross validation.
from sklearn.cross_validation import StratifiedKFold
def stratifiedKFoldVal(XTrain, YTrain, classify, params):
    n_folds = 5
    score = 0.0
    skf = StratifiedKFold(YTrain, n_folds)
    for train_index, test_index in skf:
        X_train, X_test = XTrain[train_index], XTrain[test_index]
        y_train, y_test = YTrain[train_index], YTrain[test_index]
        score += classify(X_train, X_test,  y_train, y_test, params)
    return score/n_folds

folder = 'vt'
noOfAntiVirus = 60
topNFreqFeatures = 10

XTrainFeatures = getFeatureFeqAV(newXTrain, folder, noOfAntiVirus, topNFreqFeatures)
print (XTrainFeatures.shape,XTrainFeatures[0])

XTestFeatures = getFeatureFeqAV(XTest, folder, noOfAntiVirus, topNFreqFeatures)
print (XTestFeatures.shape, XTestFeatures[0])

params = {'trees':200, 'criterion':'entropy'}
score = stratifiedKFoldVal(XTrainFeatures, newYTrain, classifyRandomForestClassifier, params)
print (score)


lstAntiVirus = [5, 10, 25, 40, 68, 75]
lstTopNFreqFeatures = [5, 10, 30, 60, 80, 100]
scoreRandomForestClassifier = []
scoreMultiClassSVMClassifier = []
scoreKNNClassifier = []

for i in range(len(lstAntiVirus)):
    folder = 'vt'
    noOfAntiVirus = lstAntiVirus[i]
    topNFreqFeatures = lstTopNFreqFeatures[i]
    #     print i
    #     print lstTopNFreqFeatures[i]

    XTrainFeatures = getFeatureFeqAV(newXTrain, folder, noOfAntiVirus, topNFreqFeatures)
    XTestFeatures = getFeatureFeqAV(XTest, folder, noOfAntiVirus, topNFreqFeatures)

    params = {'trees': 200, 'criterion': 'entropy'}
    score1 = stratifiedKFoldVal(XTrainFeatures, newYTrain, classifyRandomForestClassifier, params)

    params = {'kernel': 'linear'}
    score2 = stratifiedKFoldVal(XTrainFeatures, newYTrain, classifyMultiClassSVMClassifier, params)

    params = {'neighbours': 3}
    score3 = stratifiedKFoldVal(XTrainFeatures, newYTrain, classifyKNNClassifier, params)

    scoreRandomForestClassifier.append(score1)
    scoreMultiClassSVMClassifier.append(score2)
    scoreKNNClassifier.append(score3)

### Classification  on PE Info (Entropy Means)
    folder = 'peinfo'
    relevantSubTypes = ['pe_section']
    PEInfoTaken = ['entropy']
    XTrainFeaturesPE = CreateFeatureVecPEI(newXTrain, folder, PEInfoTaken, relevantSubTypes)
    XTestFeaturesPE = CreateFeatureVecPEI(XTest, folder, PEInfoTaken, relevantSubTypes)
    # print XTestFeaturesPE.shape, XTestFeaturesPE[0]
    # print XTrainFeaturesPE.shape,XTrainFeaturesPE[0]
    # print countNullVectors(XTrainFeaturesPE, len(VTInfoTaken))
    # print countNullVectors(XTestFeaturesPE, len(VTInfoTaken))
    params = {'trees': 200, 'criterion': 'entropy'}
    score = stratifiedKFoldVal(XTrainFeaturesPE, newYTrain, classifyRandomForestClassifier, params)
    print(score)
    scoreRandomForestClassifier.append(score)

    params = {'kernel': 'linear'}
    score = stratifiedKFoldVal(XTrainFeaturesPE, newYTrain, classifyMultiClassSVMClassifier, params)
    print(score)
    scoreMultiClassSVMClassifier.append(score)

    params = {'neighbours': 3}
    score = stratifiedKFoldVal(XTrainFeaturesPE, newYTrain, classifyKNNClassifier, params)
    print(score)
    scoreKNNClassifier.append(score)

###Classification on Combination of VT Info Feature Vectors Based on Binary Encoding and PE Info(Entropy Means)
    folder = 'vt'
    VTInfoTaken = VTRange.keys()
    XTrainFeatures = CreateFeatureVec(newXTrain, folder, VTInfoTaken)
    XTestFeatures = CreateFeatureVec(XTest, folder, VTInfoTaken)
    # print XTestFeatures.shape, XTestFeatures[0]
    # print XTrainFeatures.shape,XTrainFeatures[0]
    # print countNullVectors(XTrainFeatures, len(VTInfoTaken))
    # print countNullVectors(XTestFeatures, len(VTInfoTaken))

    folder = 'peinfo'
    relevantSubTypes = ['pe_section']
    PEInfoTaken = ['entropy']
    XTrainFeaturesPE = CreateFeatureVecPEI(newXTrain, folder, PEInfoTaken, relevantSubTypes)
    XTestFeaturesPE = CreateFeatureVecPEI(XTest, folder, PEInfoTaken, relevantSubTypes)

    XTrainClf = np.concatenate((XTrainFeatures, XTrainFeaturesPE), axis=1)
    XTestClf = np.concatenate((XTestFeatures, XTestFeaturesPE), axis=1)
    # print XTrainClf[0],XTestClf[0]
    # print XTrainClf.shape, XTestClf.shape

    clf = RandomForestClassifier(n_estimators=200, criterion='entropy')
    clf.fit(XTrainClf, newYTrain)
    YPred = clf.predict(XTestClf)
    print(YPred)
# # Just consider the top 4 anti viruses
# VTInfoTaken = ['Panda','AVware','VIPRE','Symantec']

# # The values for these 4 anti virses are one hot encoded based on the frequency and rarity of occurence.
# PandaValues = ['Adware/SaveShare', 'Generic Malware', 'Trj/CI.A', 'PUP/Somoto', 'Adware/Firseria','Suspicious file', 'PUP/InstallMonstr']
# AVwareValues = ['Backdoor.MSIL.Bladabindi.a (v)', 'Trojan.Win32.Fareit.gi (v)', 'DownloadMR (fs)']
# VIPREValues = ['Trojan.MSIL.Agent.ko (v)', 'JustPlugIt (fs)', 'Backdoor.MSIL.Bladabindi.a (v)', 'DownloadMR (fs)', 'InstallPath (fs)']
# SymantecValues = ['SoftwareVersionUpdater', 'PUA.Downloader', 'Trojan.Asprox.B!gm', 'PUA.Downloader']
#
# def createLtdOHEonAVFeaturesVecOld(X,folder,VTInfoTaken):
#     XFeatures = []
#     for i in range(X.shape[0]):
#         XFeatures.append([])
#         VTInfo = readFile(os.getcwd()+os.path.sep+folder+os.path.sep+X[i]+'.bin')
#         for key in VTInfoTaken:
#             if key in VTInfo.keys():
#                 if key == 'Panda':
#                     if VTInfo[key] in PandaValues:
#                         XFeatures[i].append(PandaValues.index(VTInfo[key]))
#                     else:
#                         XFeatures[i].append(7)
#                 elif key == 'AVware':
#                     if VTInfo[key] in AVwareValues:
#                         XFeatures[i].append(AVwareValues.index(VTInfo[key]))
#                     else:
#                         XFeatures[i].append(3)
#                 elif key == 'VIPRE':
#                     if VTInfo[key] in VIPREValues:
#                         XFeatures[i].append(VIPREValues.index(VTInfo[key]))
#                     else:
#                         XFeatures[i].append(5)
#                 elif key == 'Symantec':
#                     if VTInfo[key] in SymantecValues:
#                         XFeatures[i].append(SymantecValues.index(VTInfo[key]))
#                     else:
#                         XFeatures[i].append(4)
#             else:
#                 XFeatures[i].append(0)
#     return np.asarray(XFeatures)

##Function for Limited One Hot Encoding of Features of each Anti Virus - Classification purely on VT Info

##RF with gini index, 100 trees gave best results